-- This file was generated by fch.
-- To submit a bug report or add a language module, go to:
-- <https://github.com/llllllllll/fch>
module False.C (falseLen, falseStr) where
falseStr :: String
falseStr = "#include <stdlib.h>\n#include <stdio.h>\n\n\ntypedef struct{\n    size_t *first;\n    size_t *cur;\n    size_t *last;\n}f_stack;\n\n\ntypedef size_t f_namespace[26];\ntypedef void f_lambda(f_stack*);\n\n\nvoid f_stackinit(f_stack *stack){\n    stack->first = malloc(sizeof(size_t) * 1024);\n    stack->cur = stack->first;\n    stack->last = &stack->first[1023];\n}\n\n\nvoid f_stackpush(f_stack *stack,size_t v){\n    static size_t *t;\n    static size_t delta;\n    if (stack->cur == stack->last){\n        delta = (stack->last - stack->first) * 2;\n        stack->first = realloc(stack->first,delta);\n        stack->last = stack->first + delta;\n        stack->cur = stack->first + (delta / 2);\n    }\n    *(++stack->cur) = v;\n}\n\n\nvoid f_namespaceinit(f_namespace ns,char **argv){\n    ns[0] = argv;\n}\n\n\nvoid f_init(f_namespace ns,f_stack *stack,char **argv){\n    f_stackinit(stack);\n    f_namespaceinit(ns,argv);\n}\n\n\n\nvoid f_add(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *stack->cur;\n    *stack->cur = a + b;\n}\n\n\n\nvoid f_sub(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *stack->cur;\n    *stack->cur = a - b;\n}\n\n\nvoid f_mul(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *stack->cur;\n    *stack->cur = a * b;\n}\n\n\nvoid f_div(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *stack->cur;\n    *stack->cur = a / b;\n}\n\n\nvoid f_neg(f_stack *stack){\n    *stack->cur = -(*stack->cur);\n}\n\n\nvoid f_eq(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *stack->cur;\n    *stack->cur = a == b;\n}\n\n\nvoid f_gt(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *stack->cur;\n    *stack->cur = a > b;\n}\n\n\nvoid f_not(f_stack *stack){\n    *stack->cur = !(*stack->cur);\n}\n\n\nvoid f_and(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *stack->cur;\n    *stack->cur = a && b;\n}\n\n\nvoid f_or(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *stack->cur;\n    *stack->cur = a || b;\n}\n\n\nvoid f_assign(f_stack *stack,size_t *var){\n    *var= *(stack->cur--);\n}\n\n\nvoid f_read(f_stack *stack,size_t *var){\n    *stack->cur = *var;\n}\n\n\nvoid f_apply(f_stack *stack){\n    ((f_lambda*) *(stack->cur--))(stack);\n}\n\n\nvoid f_dup(f_stack *stack){\n    f_stackpush(stack,*stack->cur);\n}\n\n\nvoid f_del(f_stack *stack){\n    --stack->cur;\n}\n\n\n\nvoid f_swap(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *stack->cur;\n    *(stack->cur++) = a;\n    *(stack->cur) = b;\n}\n\n\nvoid f_rot(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *(stack->cur--);\n    size_t c = *stack->cur;\n    *(stack->cur++) = a;\n    *(stack->cur++) = c;\n    *stack->cur = b;\n}\n\n\nvoid f_pick(f_stack *stack){\n    f_stackpush(stack,stack->first[*(stack->cur--)]);\n}\n\n\nvoid f_if(f_stack *stack){\n    if (*(stack->cur--)){\n        f_apply(stack);\n    }\n}\n\n\nvoid f_while(f_stack *stack){\n    f_lambda *cond = (f_lambda*) *(stack->cur--);\n    f_lambda *body = (f_lambda*) *(stack->cur--);\n    size_t b;\n    cond(stack);\n    while (*(stack->cur--)){\n        body(stack);\n        cond(stack);\n    }\n}\n\n\nvoid f_printi(f_stack *stack){\n    printf(\"%d\",*(stack->cur--));\n}\n\n\nvoid f_printc(f_stack *stack){\n    putchar(*(stack->cur--));\n}\n\n\nvoid f_input(f_stack *stack){\n    f_stackpush(stack,getchar());\n}\n\n\nvoid f_flush(f_stack *stack){\n    fflush(stdout);\n}\n"
falseLen :: Int
falseLen = 3304

