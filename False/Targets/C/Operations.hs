-- This file was generated by fch.
-- To submit a bug report or add a language module, go to:
-- <https://github.com/llllllllll/fch>
module False.Targets.C.Operations (falseLen, falseStr) where
falseStr :: String
falseStr = "#include <stdlib.h>\n#include <stdio.h>\n\n\ntypedef struct{\n    size_t *first;\n    size_t *cur;\n    size_t *last;\n}f_stack;\n\n\ntypedef void f_lambda(f_stack*);\ntypedef size_t f_namespace[26];\n\nstatic f_namespace namespace;\n\n\nvoid f_stackinit(f_stack *stack){\n    stack->first = malloc(sizeof(size_t) * 1024);\n    stack->cur = stack->first;\n    stack->last = &stack->first[1023];\n}\n\n\nvoid f_stackpush(f_stack *stack,size_t v){\n    size_t delta;\n    if (stack->cur == stack->last){\n        delta = (stack->last - stack->first) * 2;\n        stack->first = realloc(stack->first,delta);\n        stack->last = stack->first + delta;\n        stack->cur = stack->first + (delta / 2);\n    }\n    stack->cur += sizeof(size_t);\n    *stack->cur = v;\n}\n\n\nvoid f_namespaceinit(f_namespace ns,char **argv){\n    ns[0] = (size_t) argv;\n}\n\n\nvoid f_init(f_namespace ns,f_stack *stack,char **argv){\n    f_stackinit(stack);\n    f_namespaceinit(ns,argv);\n}\n\n\n\nvoid f_add(f_stack *stack){\n    size_t a;\n    size_t b;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    *stack->cur = b + a;\n}\n\n\n\nvoid f_sub(f_stack *stack){\n    size_t a;\n    size_t b;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    *stack->cur = b - a;\n}\n\n\nvoid f_mul(f_stack *stack){\n    size_t a;\n    size_t b;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    *stack->cur = b * a;\n}\n\n\nvoid f_div(f_stack *stack){\n    size_t a;\n    size_t b;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    *stack->cur = b / a;\n}\n\n\nvoid f_neg(f_stack *stack){\n    *stack->cur = -(*stack->cur);\n}\n\n\nvoid f_eq(f_stack *stack){\n    size_t a;\n    size_t b;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    *stack->cur = a == b;\n}\n\n\nvoid f_gt(f_stack *stack){\n    size_t a;\n    size_t b;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    *stack->cur = b > a;\n}\n\n\nvoid f_not(f_stack *stack){\n    *stack->cur = !(*stack->cur);\n}\n\n\nvoid f_and(f_stack *stack){\n    size_t a = *(stack->cur--);\n    size_t b = *stack->cur;\n    *stack->cur = b && a;\n}\n\n\nvoid f_or(f_stack *stack){\n    size_t a;\n    size_t b;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    *stack->cur = b || a;\n}\n\n\nvoid f_assign(f_stack *stack){    size_t a;\n    size_t b;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    namespace[a]= b;\n}\n\n\nvoid f_read(f_stack *stack){\n    *stack->cur = namespace[*(stack->cur)];\n}\n\n\nvoid f_apply(f_stack *stack){\n    size_t a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    ((f_lambda*) a)(stack);\n}\n\n\nvoid f_dup(f_stack *stack){\n    f_stackpush(stack,*stack->cur);\n}\n\n\nvoid f_del(f_stack *stack){\n    stack->cur -= sizeof(size_t);\n}\n\n\n\nvoid f_swap(f_stack *stack){\n    size_t a;\n    size_t b;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    *stack->cur = a;\n    stack->cur += sizeof(size_t);\n    *stack->cur = b;\n}\n\n\nvoid f_rot(f_stack *stack){\n    size_t a;\n    size_t b;\n    size_t c;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    c = *stack->cur;\n    *stack->cur = a;\n    stack->cur += sizeof(size_t);\n    *stack->cur = c;\n    stack->cur += sizeof(size_t);\n    *stack->cur = b;\n}\n\n\nvoid f_pick(f_stack *stack){\n    size_t a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    f_stackpush(stack,stack->first[a]);\n}\n\n\nvoid f_if(f_stack *stack){\n    size_t a;\n    size_t b;\n    a = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    b = *stack->cur;\n    stack->cur -= sizeof(size_t);\n    if (b){\n        ((f_lambda*) a)(stack);\n    }\n}\n\n\nvoid f_while(f_stack *stack){\n    f_lambda *cond;\n    f_lambda *body;\n    size_t a;\n    cond = (f_lambda*) *stack->cur;\n    stack->cur -= sizeof(size_t);\n    body = (f_lambda*) *stack->cur;\n    stack->cur -= sizeof(size_t);\n    cond(stack);\n    a = *stack->cur;\n    while (a){\n        body(stack);\n        cond(stack);\n        stack->cur -= sizeof(size_t);\n    }\n}\n\n\nvoid f_printi(f_stack *stack){\n  printf(\"%ld\",*(stack->cur--));\n}\n\n\nvoid f_printc(f_stack *stack){\n    putchar(*(stack->cur--));\n}\n\n\nvoid f_input(f_stack *stack){\n    f_stackpush(stack,getchar());\n}\n\n\nvoid f_flush(f_stack *stack){\n    fflush(stdout);\n}\n"
falseLen :: Int
falseLen = 4361

